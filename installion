#!/usr/bin/env ruby

require 'rubygems'
require 'optparse'
require 'fileutils'
include FileUtils

show_help = false
open_app = false

opt_parser = OptionParser.new do |opt|
  opt.banner = "Usage: installion [OPTIONS] SOURCE [TARGET]"
  opt.on("-o","--open","Open app from source (instead of copying to target)") { open_app = true }
  opt.on("-h","--help","help") { show_help = true }
end

opt_parser.parse!
OPEN_APP = open_app

# Install an OS X package
class Installion

  def initialize(source, target=nil)
    @target = target

    # Path to temp directory
    @tmp_path = "/tmp/#{File.basename(filename(source), '.*')}"

    unless File.file? source

      # Perhaps the source exists locally?
      unless installers_path.empty?
        local_search = `find "#{installers_path}" -iname "#{filename(source)}" | head -n 1`.strip
        source = local_search unless local_search.empty?
      end

      # Source is a URL
      if source.match(/^(http|ftp)/)
        url = source

        download_path = "#{@tmp_path}/download"
        mkdir_p download_path

        source = "#{download_path}/#{filename(url)}"
        `curl "#{url}" -o "#{source}"`
      end
    end

    puts blue('Installing ') + gray(source)
    install [source]	

    # Clean up
    # rm_rf @tmp_path
  end

  def install(sources)
    sources.each do |source|	
      case this_kind_of source 

      when :dir
        install new_sources(source)

      when :zip
        unzip_path = "#{@tmp_path}/unzip"
        mkdir_p unzip_path
        cd unzip_path
        `unzip -o "#{source}"`
        puts blue('Unzipped ') + gray(source) + blue(' to ') + gray(unzip_path)

        install new_sources(unzip_path)

      when :dmg
        volume = `yes | hdiutil attach "#{source}" | grep /Volumes/`.split('/Volumes/').last.strip
        volume_path = "/Volumes/#{volume}"
        puts blue('Mounted ') + gray(source) + blue(' to ') + gray(volume_path)

        install new_sources(volume_path)

        status = `hdiutil detach "#{volume_path}" 2>&1`
        puts blue('Unmounted ') + gray(volume_path) unless status.match(/(detach failed|couldn't unmount)/)

      when :app
        `sudo mkdir -p #{applications_path}`

        if OPEN_APP 
          puts blue('Opening ') + gray(source)
          `open -a "#{source}"` 

        else
          if File.exists? "#{applications_path}/#{filename(source)}"
            puts blue('Found existing ') + gray("#{applications_path}/#{filename(source)}")

            `sudo rm -rf "#{applications_path}/#{filename(source)}"`
            puts blue('Deleted ') + gray("#{applications_path}/#{filename(source)}")
          end

          `sudo cp -R "#{source}" "#{applications_path}"`
          puts blue('Copied ') + gray(source) + blue(' to ') + gray(applications_path)
        end

      when :pkg
        `sudo mkdir -p #{packages_path}`
        `sudo -S installer -verbose -pkg "#{source}" -target "#{packages_path}"`
        puts blue('Installed ') + gray(source) + blue(' to ') + gray(packages_path)

      when :mpkg
        `sudo mkdir -p #{packages_path}`
        `sudo -S installer -verbose -pkg #{source} -target "#{packages_path}"`
        puts blue('Installed ') + gray(source) + blue(' to ') + gray(packages_path)

      when :service
        `sudo mkdir -p #{services_path}`

        if OPEN_APP 
          puts blue('Opening ') + gray(source)
          `open -a "#{source}"` 
        else
          `sudo cp -R "#{source}" "#{services_path}"`
          puts blue('Copied ') + gray(source) + blue(' to ') + gray(services_path)
        end

      when :prefPane
        `sudo mkdir -p #{preference_panes_path}`

        if OPEN_APP 
          puts blue('Opening ') + gray(source)
          `open -a "#{source}"` 
        else
          `sudo cp -R "#{source}" "#{preference_panes_path}"`
          puts blue('Copied ') + gray(source) + blue(' to ') + gray(preference_panes_path)
        end

      when :safariextz
        `open -a Safari "#{source}"`
        puts blue('Installed ') + gray(source)

      else
      end

    end
  end	

  def filename(source)
    File.basename(source).split("#").first.split("&").first.split("?").first
  end

  def this_kind_of(source)
    ext = File.extname(source).split('.').last
    return ext.to_sym if file_types.split(',').include? ext
    return :dir if File.directory? source
    :unknown
  end

  def new_sources(path)
    sources = Dir.glob "#{path}/*.{#{file_types}}" 
    directories = Dir.entries(path).select {|f| File.directory? "#{path}/#{f}" and !(f.match(/^(\.#{ignored_directories})/i)) }
    sources |= directories.each_with_index { |dir, i| directories[i] = "#{path}/#{dir}" }
  end

  def file_types
    "zip,dmg,app,pkg,mpkg,service,prefPane,safariextz"
  end

  def ignored_directories
    dirs = ENV['INSTALLION_IGNORED'] || "payloads,packages,resources,deployment"
    "|#{dirs.gsub ',', '|'}"
  end

  # Path to where installers are stored
  def installers_path
    ENV['INSTALLION_SOURCE'] || File.expand_path("~/Dropbox/Installers")
  end

  # Path to where *.app files get copied
  def applications_path 
    @target || File.expand_path("/Applications")
  end

  # Path to where *.prefPane files get copied
  def preference_panes_path
    @target || File.expand_path("~/Library/PreferencePanes")
  end

  # Path to where *.service files get copied
  def services_path
    @target || File.expand_path("~/Library/Services")
  end

  # Path to where *.pkg and *.mpkg files get installed
  def packages_path
    @target || File.expand_path("/")
  end

  def blue(text)
    "\033[34m#{text}\033[m"
  end

  def gray(text)
    "\033[37m#{text}\033[m"
  end

end


if ARGV[0]
  source = ARGV[0]
  target = ARGV[1] || nil
  Installion.new source, target
else
  show_help = true
end

puts opt_parser if show_help
